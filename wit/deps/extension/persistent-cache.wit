/// A persistent cache interface with automatic expiration.
///
/// This interface provides temporary data storage that survives application restarts,
/// designed for components that need to cache fetched or computed data.
///
/// ## Persistence and Durability
///
/// Cache entries are persisted to *disk* and survive application restarts. However,
/// entries are automatically removed when:
/// * Their time-to-live (TTL) expires
/// * They are explicitly deleted
///
/// The cache has a *storage limit* enforced by the host. When the limit is reached,
/// new `set` operations will fail with `error::storage-limit-exceeded`. When this
/// occurs, extensions must explicitly delete entries to free space before adding new ones.
///
/// ## Consistency
///
/// The cache provides strong consistency within the same application instance.
/// All operations are immediately visible to subsequent operations in the same
/// component.
interface persistent-cache {
    /// The set of errors which may be raised by cache operations.
    variant error {
        /// The host does not recognize the cache identifier requested.
        no-such-cache,

        /// The requesting component does not have access to the specified cache
        /// (which may or may not exist).
        access-denied,

        /// The cache has reached its storage limit.
        storage-limit-exceeded,

        /// Some implementation-specific error has occurred (e.g. I/O, serialization).
        other(string)
    }

    /// A response to a `list-keys` operation.
    record key-response {
        /// The list of keys returned by the query.
        keys: list<string>,
        /// The continuation token to use to fetch the next page of keys. If this is `none`, then
        /// there are no more keys to fetch.
        cursor: option<string>
    }

    /// Get the cache with the specified identifier.
    ///
    /// `identifier` must refer to a cache provided by the host.
    ///
    /// `error::no-such-cache` will be raised if the `identifier` is not recognized.
    open: func(identifier: string) -> result<cache, error>;

    /// A cache is a collection of key-value pairs with automatic expiration.
    ///
    /// Each cache provides isolated storage where keys are unique within that cache namespace.
    /// Values are stored as byte arrays, allowing extensions to use any serialization format.
    resource cache {
        /// Get the value associated with the specified `key`.
        ///
        /// The value is returned as an option. If the key-value pair exists in the
        /// cache and has not expired, it returns `Ok(some(value))`. If the key does not exist,
        /// has expired, or was evicted, it returns `Ok(none)`.
        ///
        /// This operation does NOT reset or extend the TTL of the entry.
        ///
        /// If any other error occurs, it returns an `Err(error)`.
        get: func(key: string) -> result<option<list<u8>>, error>;

        /// Set the value associated with the key in the cache.
        ///
        /// If the key already exists in the cache, it overwrites the value and resets the TTL.
        /// If the key does not exist, it creates a new key-value pair.
        ///
        /// `ttl-ms` specifies the time-to-live in milliseconds. After this duration expires,
        /// the entry is automatically removed. If `none`, the host uses a default TTL.
        ///
        /// If the cache storage limit is reached, it returns `Err(error::storage-limit-exceeded)`.
        /// If any other error occurs, it returns an `Err(error)`.
        set: func(key: string, value: list<u8>, ttl-ms: option<u32>) -> result<_, error>;

        /// Delete the key-value pair associated with the key in the cache.
        ///
        /// If the key does not exist, it does nothing.
        ///
        /// If any other error occurs, it returns an `Err(error)`.
        delete: func(key: string) -> result<_, error>;

        /// Check if the key exists in the cache and has not expired.
        ///
        /// If the key exists and is valid, it returns `Ok(true)`. If the key does not exist,
        /// has expired, or was evicted, it returns `Ok(false)`.
        ///
        /// If any other error occurs, it returns an `Err(error)`.
        exists: func(key: string) -> result<bool, error>;

        /// Get all the keys in the cache with an optional cursor (for use in pagination).
        ///
        /// It returns a list of keys. Please note that for most cache implementations, this
        /// can be an expensive operation and should be used judiciously. Implementations
        /// can return any number of keys in a single response. Any response should also return
        /// a cursor that can be used to fetch the next page of keys. See the `key-response`
        /// record for more information.
        ///
        /// Note that the keys are not guaranteed to be returned in any particular order.
        ///
        /// If the cache is empty, it returns an empty list.
        ///
        /// MAY show an out-of-date list of keys if there are concurrent writes to the cache.
        ///
        /// If any error occurs, it returns an `Err(error)`.
        list-keys: func(cursor: option<string>) -> result<key-response, error>;
    }
}
